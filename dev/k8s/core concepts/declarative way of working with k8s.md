## Create `Deployment`

`deployment.yaml`
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
	name: second-app-deployment
	
# specification of the Deployment
spec:
	replicas: 1
	
	selector:
		matchLabels:
			app: second-app
			tier: backend
			
	template:
		metadata:
		labels:
			app: second-app
			tier: backend
			
		# specification of individual Pod
		spec:
		containers:
			- name: second-node
			  image: holahoon/k8s-first-app
		  # - name: another second-node
		  #   image: another image
```

The example was to create a `Deployment` object.

- `apiVersion`: Api version must be specified. The api version can be found in the [documentation](https://kubernetes.io/docs/concepts/workloads/controllers/deployment/).
- `kind`: Type of object creating (Deployment in our case).
- `metadata`: Metadata of the object(Deployment in our case) creating.
	- `name`: Name of the object (Deployment).
- `selector`: Tells the Deployment which Pod belongs to. In our case, it has label of `app` and value of `second-app`, with label of `tier`, value of `backend`. The Pod that has the same label `app` and  `tier` will belong to the specific `Deployment` object.
- `kind`: Tells k8s what you want to create.
- `metadata`: Includes some metadata for the object creating.
- `spec`: Specification of the created object.
	- `replicas`: number of Pods.
	- `template`: defines the Pods that should be created.
The second `spec` is the specification of each Pod. A Pod is also an object, so it needs `metadata` as well. Each Pod can contain more than one image (as commented).

## Run
```bash
$ kubectl apply -f=<file-name>

# example
$ kubectl apply -f=deployment.yaml
```
- `-f=<file-name>`: which file to use.

## Create `Service`

`service.yaml`
```yaml
apiVersion: v1
kind: Service
metadata:
	name: backend

spec:
	selector:
		app: second-app
	ports:
		- protocol: 'TCP'
		  port: 80
		  targetPort: 8080
		# - protocol: 'TCP'
		#  port: 443
		#  targetPort: 443
```

- `apiVersion`: Version to use [documentation](https://kubernetes.io/docs/concepts/services-networking/service/).
- `kind`: Type of object to create.
- `metadata`: Metadata of the object creating.
	- `name`: Name of the Service.
- `spec`: Specification.
	- `selector`: which label it is going to use to work with Pods. This Service object will select and therefore expose all Pods with the label of `app` and value of `second-app`. The Pods generated by [[#Create `Deployment`]] will use this Service.
- `ports`: Port to use and expose. We can have multiple ports btw.
	- `protocol`: [Application protocol](https://kubernetes.io/docs/concepts/services-networking/service/#application-protocol).
	- `port`: Port to expose to.
	- `targetPort`: Port that the application uses (i.e. `app.listen(8080);`)
- `type`: [Type of Service](https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types).

We can apply it now:
```bash
$ kubectl apply -f=service.yaml

# check if it has successfully applied
$ kubectl get services
```

Let's now expose the Service:
```bash
$ minikube service backend
```

## Delete Resources

We can delete resources created:
```bash
$ kubectl delete -f=deployment.yaml
```
We are NOT deleting the actual file, but deleting the resources created based on that file.

To delete multiple resources:
```bash
$ kubectl delete -f=deployment.yaml,service.yaml
# or
$ kubectl delete -f=deployment.yaml -f=service.yaml
```

## Merge Resources

We can have one single config file that handles both `Deployment` and `Services`.

`master-deployment.yaml`
```yaml
---
apiVersion: v1
kind: Service
metadata:
	name: backend

spec:
	selector:
		app: second-app
	ports:
		- protocol: 'TCP'
		  port: 80
		  targetPort: 8080

---
apiVersion: apps/v1
kind: Deployment
metadata:
	name: second-app-deployment
	
# specification of the Deployment
spec:
	replicas: 1
	
	selector:
		matchLabels:
			app: second-app
			tier: backend
			
	template:
		metadata:
		labels:
			app: second-app
			tier: backend
			
		# specification of individual Pod
		spec:
		containers:
			- name: second-node
			  image: holahoon/k8s-first-app
```

Each config is separated by `---` which tells yaml file that it is a brand new object starts.
ðŸ˜Ž Note that when combining a `Deployment` and `Service` in one file, it is a good practice to put `Service` first because `Service` has a `selector`, it dynamically add any `Pods` which are created thereafter.

We can delete the existing Deployment and Service and let's try to run apply:
```bash
# delete existing deployment and service yaml
$ kubectl delete -f=deployment.yaml -f=service.yaml

# apply
$ kubectl apply -f=master-deployment.yaml
```

## More Information on Labels & Selectors

With using `Selectors`, you can only select by `labels`.
Instead of using `matchLabels`, we can also use `matchExpressions`. There's more [documentation about this](https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/).

We can have more control over the labels:
```yaml
...deployment
	selector:
		matchExpressions:
			-{key: app, operator: In, values: [second-app, first-app]}
...
```
This allows us to select labels with key `app`, that has values in `second-app`, `first-app`.

### We can also use delete by selector

We need to give the object a label a key, value pair. In this case, the key is going to be `group` and `example` as value.

`deployment.yaml`
```yaml
...
metadata:
	name: second-app-deployment
	labels:
		group: example
...
```
`service.yaml`
```yaml
...
metadata:
	name: backend
	labels:
		group: example
...
```

```bash
$ kubectl delete deployment,services -l group=example
```
The command deletes `Deployment` and `Service` with selectors with key of `group` and value of `example`.

## Using The Latest Docker Image

We can tell k8s to use the latest image from Docker Hub:
`deployment.yaml`
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
	name: second-app-deployment
...

spec:
	...
	template:
		metadata:
			...
		spec:
			containers:
				- name: second-node
				  image: holahoon/some-image:2
				  imagePullPolicy: Always
```

Even if we made changes to in our code and pushed the image to Docker Hub, and instead of updating the tag, if we still use the same tag(`holahoon/some-image:2`), k8s will not pull the image again.
But, with `imagePullPolicy` set to `Always`, it WILL always pull the latest image from Docker Hub.
[Documentation](https://kubernetes.io/docs/concepts/containers/images/#image-pull-policy)
