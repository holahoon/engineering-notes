## Create `Deployment`

`deployment.yaml`
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
	name: second-app-deployment
	
# specification of the Deployment
spec:
	replicas: 1
	
	selector:
		matchLabels:
			app: second-app
			tier: backend
			
	template:
		metadata:
		labels:
			app: second-app
			tier: backend
			
		# specification of individual Pod
		spec:
		containers:
			- name: second-node
			  image: holahoon/k8s-first-app
		  # - name: another second-node
		  #   image: another image
```

The example was to create a `Deployment` object.

- `apiVersion`: Api version must be specified. The api version can be found in the [documentation](https://kubernetes.io/docs/concepts/workloads/controllers/deployment/).
- `kind`: Type of object creating (Deployment in our case).
- `metadata`: Metadata of the object(Deployment in our case) creating.
	- `name`: Name of the object (Deployment).
- `selector`: Tells the Deployment which Pod belongs to. In our case, it has label of `app` and value of `second-app`, with label of `tier`, value of `backend`. The Pod that has the same label `app` and  `tier` will belong to the specific `Deployment` object.
- `kind`: Tells k8s what you want to create.
- `metadata`: Includes some metadata for the object creating.
- `spec`: Specification of the created object.
	- `replicas`: number of Pods.
	- `template`: defines the Pods that should be created.
The second `spec` is the specification of each Pod. A Pod is also an object, so it needs `metadata` as well. Each Pod can contain more than one image (as commented).

## Run
```bash
$ kubectl apply -f=<file-name>

# example
$ kubectl apply -f=deployment.yaml
```
- `-f=<file-name>`: which file to use.

## Create `Service`

`service.yaml`
```yaml
apiVersion: v1
kind: Service
metadata:
	name: backend

spec:
	selector:
		app: second-app
	ports:
		- protocol: 'TCP'
		  port: 80
		  targetPort: 8080
		# - protocol: 'TCP'
		#  port: 443
		#  targetPort: 443
```

- `apiVersion`: Version to use [documentation](https://kubernetes.io/docs/concepts/services-networking/service/).
- `kind`: Type of object to create.
- `metadata`: Metadata of the object creating.
	- `name`: Name of the Service.
- `spec`: Specification.
	- `selector`: which label it is going to use to work with Pods. This Service object will select and therefore expose all Pods with the label of `app` and value of `second-app`. The Pods generated by [[#Create `Deployment`]] will use this Service.
- `ports`: Port to use and expose. We can have multiple ports btw.
	- `protocol`: [Application protocol](https://kubernetes.io/docs/concepts/services-networking/service/#application-protocol).
	- `port`: Port to expose to.
	- `targetPort`: Port that the application uses (i.e. `app.listen(8080);`)
- `type`: [Type of Service](https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types).

We can apply it now:
```bash
$ kubectl apply -f=service.yaml

# check if it has successfully applied
$ kubectl get services
```

Let's now expose the Service:
```bash
$ minikube service backend
```

## Delete Resources

We can delete resources created:
```bash
$ kubectl delete -f=deployment.yaml
```
We are NOT deleting the actual file, but deleting the resources created based on that file.

If want to delete multiple resources:
```bash
$ kubectl delete -f=deployment.yaml,service.yaml
# or
$ kubectl delete -f=deployment.yaml -f=service.yaml
```

